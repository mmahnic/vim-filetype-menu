*ftmenu.txt*                 FileType Menu                     December 2010

filetype Menu                        *filetype-menu* *filetypemenu* *ftmenu*

FileType Menu plugin implements a menu that changes its contents based on the 
'filetype' of the current buffer. The menu is rebuilt every time the filetype 
of the active buffer changes or when a buffer with a different filetype is 
made active. The name of the menu is composed of the word "Mode" and of the 
current filetype (eg. "&Mode-vim"). If there are no menus defined for the 
current filetype, the FileType menu doesn't exist.

Ideally the plugins that offer menus for a certain filetype register a 
function (a hook) for each filetype menu. The ftmenu plugin calls these hooks 
when the menus have to be recreated.

Filetype menus that are created as normal menus by plugins that don't support 
the ftmenu plugin can also be managed by ftmenu if they are registered at 
startup. In this case ftmenu will save a normal menu in an internal structure 
and delete it. When ftmenu recreates the FileType menu it will execute |menu| 
commands that will recreate the normal menu under the FileType menu.

  1. Using FileType menu hooks                      |ftmenu-hooks|
  2. A workaround for existing filetype menus       |ftmenu-workaround|
  2.1 Problems with workarounds                     |ftmenu-workaround-prblm|
  3. Moving menus around                            |ftmenu-moving-menus|

1. Using FileType menu hooks                                   *ftmenu-hooks*
============================

This method should be used by plugin writers that want to suport the FileType 
menu. Here is an example of a hypothetic Vim FileType menu:
>
  " Get this script's number.
  " (This block is taken from VxLib; equiv.: exec vxlib#plugin#MakeSID())
	let s:sid_script = "map <SID>xx <SID>xx\n" .
      \ "let s:SID = substitute(maparg('<SID>xx')," .
      \      '<SNR>\\(\\d\\+_\\)xx$', '\\1', '') \n" .
      \ "unmap <SID>xx\n" .
      \ "let s:SNR = '<SNR>' . s:SID"
	exec s:sid_script

  function s:FTM_Vim(priority, menu)
    exec a:priority . "amenu " . a:menu . ".&Source :so %<cr>"
    exec a:priority . "amenu " . a:menu . ".&Test :echom 'It works'<cr>"
  endfunc

  call ftmenu#RegisterHook('VimTestMenu', s:SNR . 'FTM_Vim')
  call ftmenu#AddHook('vim', 'VimTestMenu')
<
The function that will create the menu is first registered with a unique name. 
This name is then used to associate the hook with a filetype.

Note: A two step process is used so that in a future version the user will be 
able to associate existing hooks with additional filetypes that were not 
foreseen by the plugin author. It will also be possible to put items generated 
by a hook into a separate submenu. All this would be hard to achieve if only 
function references were used.


2. A workaround for existing filetype menus               *ftmenu-workaround*
===========================================

Normal menus that should be managed by the ftmenu plugin are registered in the 
Vim startup file |.vimrc|. The global variable g:ftmenu_mode_menus is a 
dictionary that defines a list of normal menus that should be removed and 
attached to the FileType menu. In this example one menu is registered for 
filetype=sh and two for filetype=python:
>
  let g:ftmenu_mode_menus = {
     \ 'sh': ['Bash'],
     \ 'python': ['Python', 'IM-Python']
     \ }
<
The ftmenu plugin can move a menu at any depth to the FileType menu (eg. 
'Plugin.comment'). The same menu can be added to multiple filetypes.

If there are many menus associated with a mode, they can be organized into 
submenus in the FileType menu. For example the menu "IM-Python" from 
vimscript#30 holds the structures of the current Python buffer. With the above 
registrations the entries from menus "Python" and "IM-Python" are stored as 
normal items in the "Mode-python" menu:
>
   Beginning of block
   End of block
   ...
   functions
   classes
   ...
<
Instead the items of "IM-python" can be put in a submenu. This is done by 
appending "=>Submenu-Name" to the name of the original menu. If the above 
registration is changed to
>
  let g:ftmenu_mode_menus = {
     \ 'sh': ['Bash'],
     \ 'python': ['Python', 'IM-Python=>&Buffer']
     \ }
<
the FileType menu will have a submenu called "Buffer" with items "functions" 
and "classes":
>
   Beginning of block
   End of block
   ...
   Buffer               >     functions
                              classes
   ...
<

2.1 Problems with workarounds                     *ftmenu-workaround-prblm*
=============================

When a menu is moved to a new location, the original plugin may have trouble 
to update it. For example the 'IM-Python' menu above is recreated upon user 
request. The plugin complains that the menu doesn't exist and creates a new 
menu instead. To transfer the changes to the FileType menu, currently we have 
to move to a buffer with a different filetype and back.

If the command associated with a menu contains bars (|), it may not work in 
the recreated menus


3. Moving menus around                                *ftmenu-moving-menus*
======================

The ftmenu plugin exposes a few functions that enable the user to move a menu 
to a different location in the menu structure. This can be useful when many 
plugins are installed that create their own top-level menus which can make the 
menubar too large.

When moving menus the considerations from |ftmenu-workaround-prblm| apply.

ftmenu#MoveMenu(source, destination)                      *ftmenu-movemenu*

The function captures the menu from source menu path, deletes it and recreates 
its items in the destination menu path. The following call will move 
"Tools.Spelling" to the menu "Test" and the items will be created in the 
submenu "NewSpelling":
>
   call ftmenu#MoveMenu('Tools.Spelling', '&Test.New&Spelling')
<
In the process MoveMenu calls the functions CaptureMenu and CreateMenu.

ftmenu#CaptureMenu(source, existingEntries)            *ftmenu-capturemenu*

The function captures the menu from source menu path and returns a list of 
menu entries that can be used to regenerate a menu. The parameter 
existingEntries holds the entries from a previous call to CaptureMenu. This 
can be used if we want to update the entries of a previously captured menu 
(Note: the function doesn't detect if an item was deleted from the menu). This 
parameter should mostly be an empty list ( [] ), but is used internally by 
|ftmenu-workaround|.

Every entry in the returned list is a dictionary with the following fields:
    pri    a list of menu priorities
    cmd    a |menu| command to generate an entry
    menu   a list of menu parts
           menu[0]=source
           the rest is split(menupath,'.'), with source removed from menupath
    rhs    the command that is associated with the menu
           the bar (|) is escaped in rhs, but may still cause problems
    id     a unique id of the menu entry used with existingEntries

ftmenu#CreateMenu(destination, entries)

The function will create a menu item for each entry in entries with the 
following menu path:
>
    menupath = destination . '.' . join([1:], '.')
<
This means that the source from the CaptureMenu call will not be part of the 
new menu.

With CaptureMenu and CreateMenu it is possible to create a copy of a menu:
>
   let entries = ftmenu#CaptureMenu('Tools.Folding', [])
   call ftmenu#CreateMenu('&Test.Copy&Folding', entries)
<

vim:ft=help:tw=78:et:ts=2:norl:
